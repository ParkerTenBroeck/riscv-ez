use crate::node::NodeTrait;
use crate::node::Source;
use std::fmt::Write;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LogKind {
    Error,
    Warning,
    Info,
    Hint,
    From,
    Pasted,
    Generated,
    Included,
}

pub struct LogPart<T: NodeTrait> {
    pub node: Option<T>,
    pub kind: LogKind,
    pub msg: Option<String>,
}

#[derive(Default)]
pub struct LogEntry<T: NodeTrait> {
    pub parts: Vec<LogPart<T>>,
}

impl<T: NodeTrait + Clone> LogEntry<T> {
    pub fn new() -> Self {
        Self { parts: Vec::new() }
    }

    pub fn error(self, node_id: T, msg: impl ToString) -> Self {
        self.add(node_id, LogKind::Error, msg)
    }

    pub fn warning(self, node_id: T, msg: impl ToString) -> Self {
        self.add(node_id, LogKind::Warning, msg)
    }

    pub fn info(self, node_id: T, msg: impl ToString) -> Self {
        self.add(node_id, LogKind::Info, msg)
    }

    pub fn hint(self, node_id: T, msg: impl ToString) -> Self {
        self.add(node_id, LogKind::Hint, msg)
    }

    pub fn add(mut self, node_id: T, kind: LogKind, msg: impl ToString) -> Self {
        let mut node_id = Some(&node_id);
        let mut msg = Some(msg.to_string());
        let mut kind = kind;

        let position = self.parts.len();
        while let Some(node) = node_id {
            self.parts.insert(
                position,
                LogPart {
                    node: node_id.map(|f| (*f).clone()),
                    kind,
                    msg: msg.take(),
                },
            );
            if position != 0 {
                break;
            }
            use crate::context::Parent;
            match node.parent() {
                Parent::None => kind = LogKind::From,
                Parent::Included { .. } => kind = LogKind::Included,
                Parent::Pasted { .. } => kind = LogKind::Pasted,
                Parent::Generated { .. } => kind = LogKind::Generated,
            }

            node_id = node.parent().parent();
        }

        self
    }

    pub fn error_locless(self, msg: impl ToString) -> Self {
        self.add_locless(LogKind::Error, msg)
    }

    pub fn warning_locless(self, msg: impl ToString) -> Self {
        self.add_locless(LogKind::Warning, msg)
    }

    pub fn info_locless(self, msg: impl ToString) -> Self {
        self.add_locless(LogKind::Info, msg)
    }

    pub fn hint_locless(self, msg: impl ToString) -> Self {
        self.add_locless(LogKind::Hint, msg)
    }

    pub fn add_locless(mut self, kind: LogKind, msg: impl ToString) -> LogEntry<T> {
        self.parts.push(LogPart {
            node: None,
            kind,
            msg: Some(msg.to_string()),
        });
        self
    }
}

pub const BOLD: &str = "\x1b[1m";
pub const RED: &str = "\x1b[31m";
pub const YELLOW: &str = "\x1b[33m";
pub const BLUE: &str = "\x1b[34m";
pub const GREEN: &str = "\x1b[32m";
pub const RESET: &str = "\x1b[0;22m";

pub fn expand_range_to_start_end_line(
    range: std::ops::Range<usize>,
    source: &str,
) -> (std::ops::Range<usize>, &str) {
    let start = source[..range.start]
        .char_indices()
        .rev()
        .find_map(|c| (c.1 == '\n').then_some(c.0.saturating_add(1)))
        .unwrap_or(0);
    let to_end = if range.end < source.len() {
        &source[range.end..]
    } else {
        Default::default()
    };
    let end = range.end
        + to_end
            .chars()
            .position(|c| c == '\n')
            .unwrap_or(to_end.len());
    let expanded_range = start..end.min(source.len());

    (expanded_range.clone(), &source[expanded_range])
}

impl<T: NodeTrait> std::fmt::Display for LogEntry<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for part in self.parts.iter() {
            match part.kind {
                LogKind::Error => write!(f, "{BOLD}{RED}error{RESET}{RESET}{BOLD}")?,
                LogKind::Warning => write!(f, "{BOLD}{YELLOW}warning{RESET}{RESET}{BOLD}")?,
                LogKind::Info => write!(f, "{BOLD}{BLUE}info{RESET}{RESET}{BOLD}")?,
                LogKind::From => write!(f, "{BOLD}{GREEN}from{RESET}{RESET}{BOLD}")?,
                LogKind::Hint => write!(f, "{BOLD}{GREEN}hint{RESET}{RESET}{BOLD}")?,
                LogKind::Pasted => write!(f, "{BOLD}{GREEN}pasted by{RESET}{RESET}{BOLD}")?,
                LogKind::Generated => write!(f, "{BOLD}{GREEN}generated by{RESET}{RESET}{BOLD}")?,
                LogKind::Included => write!(f, "{BOLD}{GREEN}included by{RESET}{RESET}{BOLD}")?,
            }

            if let Some(msg) = &part.msg {
                write!(f, ": {msg}")?;
            }

            let Some(node) = part.node.as_ref() else {
                writeln!(f)?;
                continue;
            };
            let span = node.span();
            let source = &node.source();

            let error_range = span.offset as usize..(span.offset as usize + span.len as usize);
            let (expanded_range, expanded) =
                expand_range_to_start_end_line(error_range.clone(), source.contents());
            let mut line = span.line as usize + 1;
            let end_line = line + expanded.lines().count();
            let max_line_digits = end_line.ilog10() as usize + 1;

            writeln!(
                f,
                "{BLUE}{BOLD}\n{: >max_line_digits$}---> {RESET}{}:{}:{}",
                " ",
                source.path().display(),
                line,
                span.col + 1
            )?;
            writeln!(f, "{BLUE}{BOLD}{: >max_line_digits$} |", "")?;

            let mut index = expanded_range.start;
            for line_contents in expanded.split('\n') {
                write!(f, "{line: >max_line_digits$} |{RESET} ")?;
                for char in line_contents.chars() {
                    if char == '\t' {
                        f.write_char(' ')?
                    } else {
                        f.write_char(char)?
                    }
                }
                writeln!(f)?;
                write!(f, "{BLUE}{BOLD}{: >max_line_digits$} | ", "")?;
                for c in line_contents.chars() {
                    if error_range.contains(&index) {
                        write!(f, "~")?;
                    } else {
                        write!(f, " ")?;
                    }
                    index += c.len_utf8();
                }
                //nl
                if error_range.contains(&index) || error_range.is_empty() {
                    write!(f, "~")?;
                } else {
                    write!(f, " ")?;
                }
                index += '\n'.len_utf8();
                writeln!(f)?;

                line += 1;
            }
            write!(f, "{RESET}")?
        }
        Ok(())
    }
}
